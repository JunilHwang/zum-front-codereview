# Intersection Observer API를 이용한 lazy-loading/infinite-scroll

- window에 scroll event를 걸고, innerHeight, scrollHeight 등을 매번 계산하는 방식은 매우 비효율적
  - 특히 이미지 개수가 많아지거나, 모바일 환경 등

## Intersection Observer의 기능

콜백 생성

- target Element가 viewport나 특정 요소(root)와 교차할 때
- 최초로 target 관측하도록 요청받을 때마다

## Syntax

```javascript
const callback = (entries, observer) => {
  /**
   * @typedef {Object} EntryType
   * @property {DOMRectReadOnly} boundingClientRect
   * @property {number} intersectionRatio
   * @property {DOMRectReadOnly} intersectionRect
   * @property {boolean} isIntersecting
   * @property {Element} [rootBounds]
   * @property {Element} target
   * @property {number} time
   */
  entries.forEach((entry) => {
    if (!entry.isIntersecting) return;
    /**
     * @todo intersected 상태에서 할 로직 구현
     */

    // 작업 끝나고 더이상 observer 가 작동할 필요 없는 경우
    observer.disconnect();
  });
};

const options = {
  /**
   * root
   * 기준이 되는 요소
   * - 대상 객체의 조상요소여야 함
   * - default : viewport
   */
  root: document.querySelector("#scrollArea"),

  /**
   * rootMargin
   * root가 가진 여백
   * - CSS margin과 유사; top/right/bottom/left
   * - defualt: 0
   */
  rootMargin: "0px",

  /**
   * threshold
   * target 요소가 root 내에서 몇 % 보여질때 호출할 것인지
   * - default: 0
   * - 배열 가능: ex. 25% 단위로 콜백실행하고 싶으면 [0, 0.25, 0.5, 0.75, 1]
   */
  threshold: 1.0,
};

const observer = new IntersectionObserver(callback, options);

const target = document.querySelector("#listItem");
observer.observe(target);
```

---

## references

- [Intersection Observer API(MDN)](https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API)
- [Intersection Observer for Lazy-Loaded Images(Fireship)](https://fireship.io/snippets/intersection-observer-lazy-load-images/)
- [Lazy Load with IntersectionObserver API(Codepen)](https://codepen.io/Jinksi/pen/BZXORO)
